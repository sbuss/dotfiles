# make bash autocomplete with up arrow
bind '"\e[A":history-search-backward'
bind '"\e[B":history-search-forward'

# Git completion
# if on osx then 'brew install bash-completion'
# see https://github.com/bobthecow/git-flow-completion/wiki/Install-Bash-git-completion
if hash brew 2> /dev/null; then
    if [ -f `brew --prefix`/etc/bash_completion ]; then
	. `brew --prefix`/etc/bash_completion
    fi
fi

alias cim='vim'

#alias go='open'

alias sqlite='sqlite3'

alias cw='cd ~/workspace'

# Find and delete all pyc files
alias rmpyc='find . -name "*.pyc" -delete'
alias pygrep='grep --include=*.py --exclude="*migrations*"'
alias hgrep='grep --include=*.html'

# This loads RVM into a shell session.
[[ -s "/Users/steven/.rvm/scripts/rvm" ]] && source "/Users/steven/.rvm/scripts/rvm"

# Git aliases
alias gb="git branch"
alias gs="git status"
alias gc="git checkout"
alias ga="git add"
alias gl="git log --graph"
alias glm="gl master.."
alias gp="git pull"
alias gpr="git pull --rebase"
alias gd="git diff"
alias push='git push origin `git rev-parse --abbrev-ref HEAD`'
alias whatdidido='git log --all --author=$USER --since=1.weeks --graph --decorate'

# Clean up merged local branches (that don't match dev or master)
function git-mop {
  commit=$1
  to_delete=`git branch --merged | egrep -v '^. (dev|master)$'`
  if [ -z "$to_delete" ]; then
    echo "No branches to delete"
  else
    if [[ $commit == "-c" ]]; then
      git branch -d $to_delete
      git prune
    else
      echo "$to_delete"
    fi
  fi
}

# Mysql config
#export PATH=$PATH:/usr/local/mysql/bin
#export DYLD_LIBRARY_PATH=/usr/local/mysql/lib:$DYLD_LIBRARY_PATH

# Python development
export PATH=/usr/local/share/python:$PATH
export WORKON_HOME=$HOME/envs
export VIRTUALENVWRAPPER_PYTHON=/usr/local/bin/python
# Work and home have different paths
if [ -f /usr/local/bin/virtualenvwrapper.sh ]; then
    source /usr/local/bin/virtualenvwrapper.sh
fi
if [ -f /usr/local/share/python/virtualenvwrapper.sh ]; then
    source /usr/local/share/python/virtualenvwrapper.sh
fi
# Make pip always install files into the current virtualenv
export PIP_RESPECT_VIRTUALENV=true

# etc
export PATH=$HOME/bin:$PATH

[[ -s "/Users/sbuss/.rvm/scripts/rvm" ]] && source "/Users/sbuss/.rvm/scripts/rvm" # Load RVM into a shell session *as a function*

# Make sure we're using Homebrew's python binary by default
export PATH=/usr/local/bin:$PATH

export PATH=/usr/local/share/npm/bin:$PATH
export PATH=/usr/local/lib/node_modules:$PATH

# ctags - perform this from project root
alias tags="hash -r && ctags -R --python-kinds=-i ."

# Go development
export PATH=$PATH:/usr/local/opt/go/libexec/bin
export GOPATH=/Users/sbuss/gopkgs
export PATH=$PATH:$GOPATH/bin
#alias gop="ln -s $1 $GOPATH/$2"
addgopkg () {
	ln -s $1 $GOPATH/src/$2
}
alias gop=addgopkg

# Postgres recovery
alias restartpostgres="rm /usr/local/var/postgres/postmaster.pid && pg_ctl -D /usr/local/var/postgres -l /usr/local/var/postgres/server.log start"


# wrap_alias provides argument tab-completion in bash.
# From http://stackoverflow.com/a/1793178
# wrap_alias takes three arguments:
# $1: The name of the alias
# $2: The command used in the alias
# $3: The arguments in the alias all in one string
# Generate a wrapper completion function (completer) for an alias
# based on the command and the given arguments, if there is a
# completer for the command, and set the wrapper as the completer for
# the alias.
function wrap_alias() {
  [[ "$#" == 3 ]] || return 1

  local alias_name="$1"
  local aliased_command="$2"
  local alias_arguments="$3"
  local num_alias_arguments=$(echo "$alias_arguments" | wc -w)

  # The completion currently being used for the aliased command.
  local completion=$(complete -p $aliased_command 2> /dev/null)

  # Only a completer based on a function can be wrapped so look for -F
  # in the current completion. This check will also catch commands
  # with no completer for which $completion will be empty.
  echo $completion | grep -q -- -F || return 0

  local namespace=alias_completion::

  # Extract the name of the completion function from a string that
  # looks like: something -F function_name something
  # First strip the beginning of the string up to the function name by
  # removing "* -F " from the front.
  local completion_function=${completion##* -F }
  # Then strip " *" from the end, leaving only the function name.
  completion_function=${completion_function%% *}

  # Try to prevent an infinite loop by not wrapping a function
  # generated by this function. This can happen when the user runs
  # this twice for an alias like ls='ls --color=auto' or alias l='ls'
  # and alias ls='l foo'
  [[ "${completion_function#$namespace}" != $completion_function ]] && return 0

  local wrapper_name="${namespace}${alias_name}"

  eval "
function ${wrapper_name}() {
  ((COMP_CWORD+=$num_alias_arguments))
  args=( \"${alias_arguments}\" )
  COMP_WORDS=( $aliased_command \${args[@]} \${COMP_WORDS[@]:1} )
  $completion_function
  }
"

  # To create the new completion we use the old one with two
  # replacements:
  # 1) Replace the function with the wrapper.
  local new_completion=${completion/-F * /-F $wrapper_name }
  # 2) Replace the command being completed with the alias.
  new_completion="${new_completion% *} $alias_name"

  eval "$new_completion"
}

# For each defined alias, extract the necessary elements and use them
# to call wrap_alias.
eval "$(alias -p | sed -e 's/alias \([^=][^=]*\)='\''\([^ ][^ ]*\) *\(.*\)'\''/wrap_alias \1 \2 '\''\3'\'' /')"

unset wrap_alias

# Connect docker client to boot2docker VM
#export DOCKER_HOST=tcp://
export DOCKER_HOST=tcp://192.168.59.103:2376
export DOCKER_TLS_VERIFY=1
export DOCKER_CERT_PATH=$HOME/.boot2docker/certs/boot2docker-vm
